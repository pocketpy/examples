{"mappings":"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","sources":["<anon>","node_modules/monaco-editor/esm/vs/basic-languages/freemarker2/freemarker2.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"24mxT\", function(module, exports) {\n\n$parcel$export(module.exports, \"TagAngleInterpolationDollar\", () => $181d7191d7e7a5bf$export$9945f5d7c02ad2fc);\n$parcel$export(module.exports, \"TagBracketInterpolationDollar\", () => $181d7191d7e7a5bf$export$6f4f6c4e91d5ee59);\n$parcel$export(module.exports, \"TagAngleInterpolationBracket\", () => $181d7191d7e7a5bf$export$1cb623f6377415e8);\n$parcel$export(module.exports, \"TagBracketInterpolationBracket\", () => $181d7191d7e7a5bf$export$d0605717f8750fe2);\n$parcel$export(module.exports, \"TagAutoInterpolationDollar\", () => $181d7191d7e7a5bf$export$b685ef20e1dddf83);\n$parcel$export(module.exports, \"TagAutoInterpolationBracket\", () => $181d7191d7e7a5bf$export$d2238c7b2ec81a45);\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.48.0(0037b13fb5d186fdf1e7df51a9416a2de2b8c670)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/ \nvar $cDseA = parcelRequire(\"cDseA\");\nvar $181d7191d7e7a5bf$var$__defProp = Object.defineProperty;\nvar $181d7191d7e7a5bf$var$__getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar $181d7191d7e7a5bf$var$__getOwnPropNames = Object.getOwnPropertyNames;\nvar $181d7191d7e7a5bf$var$__hasOwnProp = Object.prototype.hasOwnProperty;\nvar $181d7191d7e7a5bf$var$__copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of $181d7191d7e7a5bf$var$__getOwnPropNames(from))if (!$181d7191d7e7a5bf$var$__hasOwnProp.call(to, key) && key !== except) $181d7191d7e7a5bf$var$__defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = $181d7191d7e7a5bf$var$__getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar $181d7191d7e7a5bf$var$__reExport = (target, mod, secondTarget)=>($181d7191d7e7a5bf$var$__copyProps(target, mod, \"default\"), secondTarget && $181d7191d7e7a5bf$var$__copyProps(secondTarget, mod, \"default\"));\n// src/fillers/monaco-editor-core.ts\nvar $181d7191d7e7a5bf$var$monaco_editor_core_exports = {};\n$181d7191d7e7a5bf$var$__reExport($181d7191d7e7a5bf$var$monaco_editor_core_exports, $cDseA);\n// src/basic-languages/freemarker2/freemarker2.ts\nvar $181d7191d7e7a5bf$var$EMPTY_ELEMENTS = [\n    \"assign\",\n    \"flush\",\n    \"ftl\",\n    \"return\",\n    \"global\",\n    \"import\",\n    \"include\",\n    \"break\",\n    \"continue\",\n    \"local\",\n    \"nested\",\n    \"nt\",\n    \"setting\",\n    \"stop\",\n    \"t\",\n    \"lt\",\n    \"rt\",\n    \"fallback\"\n];\nvar $181d7191d7e7a5bf$var$BLOCK_ELEMENTS = [\n    \"attempt\",\n    \"autoesc\",\n    \"autoEsc\",\n    \"compress\",\n    \"comment\",\n    \"escape\",\n    \"noescape\",\n    \"function\",\n    \"if\",\n    \"list\",\n    \"items\",\n    \"sep\",\n    \"macro\",\n    \"noparse\",\n    \"noParse\",\n    \"noautoesc\",\n    \"noAutoEsc\",\n    \"outputformat\",\n    \"switch\",\n    \"visit\",\n    \"recurse\"\n];\nvar $181d7191d7e7a5bf$var$TagSyntaxAngle = {\n    close: \">\",\n    id: \"angle\",\n    open: \"<\"\n};\nvar $181d7191d7e7a5bf$var$TagSyntaxBracket = {\n    close: \"\\\\]\",\n    id: \"bracket\",\n    open: \"\\\\[\"\n};\nvar $181d7191d7e7a5bf$var$TagSyntaxAuto = {\n    close: \"[>\\\\]]\",\n    id: \"auto\",\n    open: \"[<\\\\[]\"\n};\nvar $181d7191d7e7a5bf$var$InterpolationSyntaxDollar = {\n    close: \"\\\\}\",\n    id: \"dollar\",\n    open1: \"\\\\$\",\n    open2: \"\\\\{\"\n};\nvar $181d7191d7e7a5bf$var$InterpolationSyntaxBracket = {\n    close: \"\\\\]\",\n    id: \"bracket\",\n    open1: \"\\\\[\",\n    open2: \"=\"\n};\nfunction $181d7191d7e7a5bf$var$createLangConfiguration(ts) {\n    return {\n        brackets: [\n            [\n                \"<\",\n                \">\"\n            ],\n            [\n                \"[\",\n                \"]\"\n            ],\n            [\n                \"(\",\n                \")\"\n            ],\n            [\n                \"{\",\n                \"}\"\n            ]\n        ],\n        comments: {\n            blockComment: [\n                `${ts.open}--`,\n                `--${ts.close}`\n            ]\n        },\n        autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n        autoClosingPairs: [\n            {\n                open: \"{\",\n                close: \"}\"\n            },\n            {\n                open: \"[\",\n                close: \"]\"\n            },\n            {\n                open: \"(\",\n                close: \")\"\n            },\n            {\n                open: '\"',\n                close: '\"',\n                notIn: [\n                    \"string\"\n                ]\n            },\n            {\n                open: \"'\",\n                close: \"'\",\n                notIn: [\n                    \"string\"\n                ]\n            }\n        ],\n        surroundingPairs: [\n            {\n                open: '\"',\n                close: '\"'\n            },\n            {\n                open: \"'\",\n                close: \"'\"\n            },\n            {\n                open: \"{\",\n                close: \"}\"\n            },\n            {\n                open: \"[\",\n                close: \"]\"\n            },\n            {\n                open: \"(\",\n                close: \")\"\n            },\n            {\n                open: \"<\",\n                close: \">\"\n            }\n        ],\n        folding: {\n            markers: {\n                start: new RegExp(`${ts.open}#(?:${$181d7191d7e7a5bf$var$BLOCK_ELEMENTS.join(\"|\")})([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`),\n                end: new RegExp(`${ts.open}/#(?:${$181d7191d7e7a5bf$var$BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n            }\n        },\n        onEnterRules: [\n            {\n                beforeText: new RegExp(`${ts.open}#(?!(?:${$181d7191d7e7a5bf$var$EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`),\n                afterText: new RegExp(`^${ts.open}/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*${ts.close}$`),\n                action: {\n                    indentAction: $181d7191d7e7a5bf$var$monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n                }\n            },\n            {\n                beforeText: new RegExp(`${ts.open}#(?!(?:${$181d7191d7e7a5bf$var$EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`),\n                action: {\n                    indentAction: $181d7191d7e7a5bf$var$monaco_editor_core_exports.languages.IndentAction.Indent\n                }\n            }\n        ]\n    };\n}\nfunction $181d7191d7e7a5bf$var$createLangConfigurationAuto() {\n    return {\n        // Cannot set block comment delimiter in auto mode...\n        // It depends on the content and the cursor position of the file...\n        brackets: [\n            [\n                \"<\",\n                \">\"\n            ],\n            [\n                \"[\",\n                \"]\"\n            ],\n            [\n                \"(\",\n                \")\"\n            ],\n            [\n                \"{\",\n                \"}\"\n            ]\n        ],\n        autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n        autoClosingPairs: [\n            {\n                open: \"{\",\n                close: \"}\"\n            },\n            {\n                open: \"[\",\n                close: \"]\"\n            },\n            {\n                open: \"(\",\n                close: \")\"\n            },\n            {\n                open: '\"',\n                close: '\"',\n                notIn: [\n                    \"string\"\n                ]\n            },\n            {\n                open: \"'\",\n                close: \"'\",\n                notIn: [\n                    \"string\"\n                ]\n            }\n        ],\n        surroundingPairs: [\n            {\n                open: '\"',\n                close: '\"'\n            },\n            {\n                open: \"'\",\n                close: \"'\"\n            },\n            {\n                open: \"{\",\n                close: \"}\"\n            },\n            {\n                open: \"[\",\n                close: \"]\"\n            },\n            {\n                open: \"(\",\n                close: \")\"\n            },\n            {\n                open: \"<\",\n                close: \">\"\n            }\n        ],\n        folding: {\n            markers: {\n                start: new RegExp(`[<\\\\[]#(?:${$181d7191d7e7a5bf$var$BLOCK_ELEMENTS.join(\"|\")})([^/>\\\\]]*(?!/)[>\\\\]])[^<\\\\[]*$`),\n                end: new RegExp(`[<\\\\[]/#(?:${$181d7191d7e7a5bf$var$BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n            }\n        },\n        onEnterRules: [\n            {\n                beforeText: new RegExp(`[<\\\\[]#(?!(?:${$181d7191d7e7a5bf$var$EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`),\n                afterText: new RegExp(`^[<\\\\[]/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*[>\\\\]]$`),\n                action: {\n                    indentAction: $181d7191d7e7a5bf$var$monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n                }\n            },\n            {\n                beforeText: new RegExp(`[<\\\\[]#(?!(?:${$181d7191d7e7a5bf$var$EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`),\n                action: {\n                    indentAction: $181d7191d7e7a5bf$var$monaco_editor_core_exports.languages.IndentAction.Indent\n                }\n            }\n        ]\n    };\n}\nfunction $181d7191d7e7a5bf$var$createMonarchLanguage(ts, is) {\n    const id = `_${ts.id}_${is.id}`;\n    const s = (name)=>name.replace(/__id__/g, id);\n    const r = (regexp)=>{\n        const source = regexp.source.replace(/__id__/g, id);\n        return new RegExp(source, regexp.flags);\n    };\n    return {\n        // Settings\n        unicode: true,\n        includeLF: false,\n        start: s(\"default__id__\"),\n        ignoreCase: false,\n        defaultToken: \"invalid\",\n        tokenPostfix: `.freemarker2`,\n        brackets: [\n            {\n                open: \"{\",\n                close: \"}\",\n                token: \"delimiter.curly\"\n            },\n            {\n                open: \"[\",\n                close: \"]\",\n                token: \"delimiter.square\"\n            },\n            {\n                open: \"(\",\n                close: \")\",\n                token: \"delimiter.parenthesis\"\n            },\n            {\n                open: \"<\",\n                close: \">\",\n                token: \"delimiter.angle\"\n            }\n        ],\n        // Dynamic RegExp\n        [s(\"open__id__\")]: new RegExp(ts.open),\n        [s(\"close__id__\")]: new RegExp(ts.close),\n        [s(\"iOpen1__id__\")]: new RegExp(is.open1),\n        [s(\"iOpen2__id__\")]: new RegExp(is.open2),\n        [s(\"iClose__id__\")]: new RegExp(is.close),\n        // <#START_TAG : \"<\" | \"<#\" | \"[#\">\n        // <#END_TAG : \"</\" | \"</#\" | \"[/#\">\n        [s(\"startTag__id__\")]: r(/(@open__id__)(#)/),\n        [s(\"endTag__id__\")]: r(/(@open__id__)(\\/#)/),\n        [s(\"startOrEndTag__id__\")]: r(/(@open__id__)(\\/?#)/),\n        // <#CLOSE_TAG1 : (<BLANK>)* (\">\" | \"]\")>\n        [s(\"closeTag1__id__\")]: r(/((?:@blank)*)(@close__id__)/),\n        // <#CLOSE_TAG2 : (<BLANK>)* (\"/\")? (\">\" | \"]\")>\n        [s(\"closeTag2__id__\")]: r(/((?:@blank)*\\/?)(@close__id__)/),\n        // Static RegExp\n        // <#BLANK : \" \" | \"\\t\" | \"\\n\" | \"\\r\">\n        blank: /[ \\t\\n\\r]/,\n        // <FALSE : \"false\">\n        // <TRUE : \"true\">\n        // <IN : \"in\">\n        // <AS : \"as\">\n        // <USING : \"using\">\n        keywords: [\n            \"false\",\n            \"true\",\n            \"in\",\n            \"as\",\n            \"using\"\n        ],\n        // Directive names that cannot have an expression parameters and cannot be self-closing\n        // E.g. <#if id==2> ... </#if>\n        directiveStartCloseTag1: /attempt|recover|sep|auto[eE]sc|no(?:autoe|AutoE)sc|compress|default|no[eE]scape|comment|no[pP]arse/,\n        // Directive names that cannot have an expression parameter and can be self-closing\n        // E.g. <#if> ... <#else>  ... </#if>\n        // E.g. <#if> ... <#else /></#if>\n        directiveStartCloseTag2: /else|break|continue|return|stop|flush|t|lt|rt|nt|nested|recurse|fallback|ftl/,\n        // Directive names that can have an expression parameter and cannot be self-closing\n        // E.g. <#if id==2> ... </#if>\n        directiveStartBlank: /if|else[iI]f|list|for[eE]ach|switch|case|assign|global|local|include|import|function|macro|transform|visit|stop|return|call|setting|output[fF]ormat|nested|recurse|escape|ftl|items/,\n        // Directive names that can have an end tag\n        // E.g. </#if>\n        directiveEndCloseTag1: /if|list|items|sep|recover|attempt|for[eE]ach|local|global|assign|function|macro|output[fF]ormat|auto[eE]sc|no(?:autoe|AutoE)sc|compress|transform|switch|escape|no[eE]scape/,\n        // <#ESCAPED_CHAR :\n        //     \"\\\\\"\n        //     (\n        //         (\"n\" | \"t\" | \"r\" | \"f\" | \"b\" | \"g\" | \"l\" | \"a\" | \"\\\\\" | \"'\" | \"\\\"\" | \"{\" | \"=\")\n        //         |\n        //         (\"x\" [\"0\"-\"9\", \"A\"-\"F\", \"a\"-\"f\"])\n        //     )\n        // >\n        // Note: While the JavaCC tokenizer rule only specifies one hex digit,\n        // FreeMarker actually interprets up to 4 hex digits.\n        escapedChar: /\\\\(?:[ntrfbgla\\\\'\"\\{=]|(?:x[0-9A-Fa-f]{1,4}))/,\n        // <#ASCII_DIGIT: [\"0\" - \"9\"]>\n        asciiDigit: /[0-9]/,\n        // <INTEGER : ([\"0\"-\"9\"])+>\n        integer: /[0-9]+/,\n        // <#NON_ESCAPED_ID_START_CHAR:\n        // [\n        // \t  // This was generated on JDK 1.8.0_20 Win64 with src/main/misc/identifierChars/IdentifierCharGenerator.java\n        //    ...\n        // ]\n        nonEscapedIdStartChar: /[\\$@-Z_a-z\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u1FFF\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183-\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3006\\u3031-\\u3035\\u303B-\\u303C\\u3040-\\u318F\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3300-\\u337F\\u3400-\\u4DB5\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n        // <#ESCAPED_ID_CHAR: \"\\\\\" (\"-\" | \".\" | \":\" | \"#\")>\n        escapedIdChar: /\\\\[\\-\\.:#]/,\n        // <#ID_START_CHAR: <NON_ESCAPED_ID_START_CHAR>|<ESCAPED_ID_CHAR>>\n        idStartChar: /(?:@nonEscapedIdStartChar)|(?:@escapedIdChar)/,\n        // <ID: <ID_START_CHAR> (<ID_START_CHAR>|<ASCII_DIGIT>)*>\n        id: /(?:@idStartChar)(?:(?:@idStartChar)|(?:@asciiDigit))*/,\n        // Certain keywords / operators are allowed to index hashes\n        //\n        // Expression DotVariable(Expression exp) :\n        // {\n        // \tToken t;\n        // }\n        // {\n        // \t\t<DOT>\n        // \t\t(\n        // \t\t\tt = <ID> | t = <TIMES> | t = <DOUBLE_STAR>\n        // \t\t\t|\n        // \t\t\t(\n        // \t\t\t\tt = <LESS_THAN>\n        // \t\t\t\t|\n        // \t\t\t\tt = <LESS_THAN_EQUALS>\n        // \t\t\t\t|\n        // \t\t\t\tt = <ESCAPED_GT>\n        // \t\t\t\t|\n        // \t\t\t\tt = <ESCAPED_GTE>\n        // \t\t\t\t|\n        // \t\t\t\tt = <FALSE>\n        // \t\t\t\t|\n        // \t\t\t\tt = <TRUE>\n        // \t\t\t\t|\n        // \t\t\t\tt = <IN>\n        // \t\t\t\t|\n        // \t\t\t\tt = <AS>\n        // \t\t\t\t|\n        // \t\t\t\tt = <USING>\n        // \t\t\t)\n        // \t\t\t{\n        // \t\t\t\tif (!Character.isLetter(t.image.charAt(0))) {\n        // \t\t\t\t\tthrow new ParseException(t.image + \" is not a valid identifier.\", template, t);\n        // \t\t\t\t}\n        // \t\t\t}\n        // \t\t)\n        // \t\t{\n        // \t\t\tnotListLiteral(exp, \"hash\");\n        // \t\t\tnotStringLiteral(exp, \"hash\");\n        // \t\t\tnotBooleanLiteral(exp, \"hash\");\n        // \t\t\tDot dot = new Dot(exp, t.image);\n        // \t\t\tdot.setLocation(template, exp, t);\n        // \t\t\treturn dot;\n        // \t\t}\n        // }\n        specialHashKeys: /\\*\\*|\\*|false|true|in|as|using/,\n        // <DOUBLE_EQUALS : \"==\">\n        // <EQUALS : \"=\">\n        // <NOT_EQUALS : \"!=\">\n        // <PLUS_EQUALS : \"+=\">\n        // <MINUS_EQUALS : \"-=\">\n        // <TIMES_EQUALS : \"*=\">\n        // <DIV_EQUALS : \"/=\">\n        // <MOD_EQUALS : \"%=\">\n        // <PLUS_PLUS : \"++\">\n        // <MINUS_MINUS : \"--\">\n        // <LESS_THAN_EQUALS : \"lte\" | \"\\\\lte\" | \"<=\" | \"&lt;=\">\n        // <LESS_THAN : \"lt\" | \"\\\\lt\" | \"<\" | \"&lt;\">\n        // <ESCAPED_GTE : \"gte\" | \"\\\\gte\" | \"&gt;=\">\n        // <ESCAPED_GT: \"gt\" | \"\\\\gt\" |  \"&gt;\">\n        // <DOUBLE_STAR : \"**\">\n        // <PLUS : \"+\">\n        // <MINUS : \"-\">\n        // <TIMES : \"*\">\n        // <PERCENT : \"%\">\n        // <AND : \"&\" | \"&&\" | \"&amp;&amp;\" | \"\\\\and\" >\n        // <OR : \"|\" | \"||\">\n        // <EXCLAM : \"!\">\n        // <COMMA : \",\">\n        // <SEMICOLON : \";\">\n        // <COLON : \":\">\n        // <ELLIPSIS : \"...\">\n        // <DOT_DOT_ASTERISK : \"..*\" >\n        // <DOT_DOT_LESS : \"..<\" | \"..!\" >\n        // <DOT_DOT : \"..\">\n        // <EXISTS : \"??\">\n        // <BUILT_IN : \"?\">\n        // <LAMBDA_ARROW : \"->\" | \"-&gt;\">\n        namedSymbols: /&lt;=|&gt;=|\\\\lte|\\\\lt|&lt;|\\\\gte|\\\\gt|&gt;|&amp;&amp;|\\\\and|-&gt;|->|==|!=|\\+=|-=|\\*=|\\/=|%=|\\+\\+|--|<=|&&|\\|\\||:|\\.\\.\\.|\\.\\.\\*|\\.\\.<|\\.\\.!|\\?\\?|=|<|\\+|-|\\*|\\/|%|\\||\\.\\.|\\?|!|&|\\.|,|;/,\n        arrows: [\n            \"->\",\n            \"-&gt;\"\n        ],\n        delimiters: [\n            \";\",\n            \":\",\n            \",\",\n            \".\"\n        ],\n        stringOperators: [\n            \"lte\",\n            \"lt\",\n            \"gte\",\n            \"gt\"\n        ],\n        noParseTags: [\n            \"noparse\",\n            \"noParse\",\n            \"comment\"\n        ],\n        tokenizer: {\n            // Parser states\n            // Plain text\n            [s(\"default__id__\")]: [\n                {\n                    include: s(\"@directive_token__id__\")\n                },\n                {\n                    include: s(\"@interpolation_and_text_token__id__\")\n                }\n            ],\n            // A FreeMarker expression inside a directive, e.g. <#if 2<3>\n            [s(\"fmExpression__id__.directive\")]: [\n                {\n                    include: s(\"@blank_and_expression_comment_token__id__\")\n                },\n                {\n                    include: s(\"@directive_end_token__id__\")\n                },\n                {\n                    include: s(\"@expression_token__id__\")\n                }\n            ],\n            // A FreeMarker expression inside an interpolation, e.g. ${2+3}\n            [s(\"fmExpression__id__.interpolation\")]: [\n                {\n                    include: s(\"@blank_and_expression_comment_token__id__\")\n                },\n                {\n                    include: s(\"@expression_token__id__\")\n                },\n                {\n                    include: s(\"@greater_operators_token__id__\")\n                }\n            ],\n            // In an expression and inside a not-yet closed parenthesis / bracket\n            [s(\"inParen__id__.plain\")]: [\n                {\n                    include: s(\"@blank_and_expression_comment_token__id__\")\n                },\n                {\n                    include: s(\"@directive_end_token__id__\")\n                },\n                {\n                    include: s(\"@expression_token__id__\")\n                }\n            ],\n            [s(\"inParen__id__.gt\")]: [\n                {\n                    include: s(\"@blank_and_expression_comment_token__id__\")\n                },\n                {\n                    include: s(\"@expression_token__id__\")\n                },\n                {\n                    include: s(\"@greater_operators_token__id__\")\n                }\n            ],\n            // Expression for the unified call, e.g. <@createMacro() ... >\n            [s(\"noSpaceExpression__id__\")]: [\n                {\n                    include: s(\"@no_space_expression_end_token__id__\")\n                },\n                {\n                    include: s(\"@directive_end_token__id__\")\n                },\n                {\n                    include: s(\"@expression_token__id__\")\n                }\n            ],\n            // For the function of a unified call. Special case for when the\n            // expression is a simple identifier.\n            // <@join [1,2] \",\">\n            // <@null!join [1,2] \",\">\n            [s(\"unifiedCall__id__\")]: [\n                {\n                    include: s(\"@unified_call_token__id__\")\n                }\n            ],\n            // For singly and doubly quoted string (that may contain interpolations)\n            [s(\"singleString__id__\")]: [\n                {\n                    include: s(\"@string_single_token__id__\")\n                }\n            ],\n            [s(\"doubleString__id__\")]: [\n                {\n                    include: s(\"@string_double_token__id__\")\n                }\n            ],\n            // For singly and doubly quoted string (that may not contain interpolations)\n            [s(\"rawSingleString__id__\")]: [\n                {\n                    include: s(\"@string_single_raw_token__id__\")\n                }\n            ],\n            [s(\"rawDoubleString__id__\")]: [\n                {\n                    include: s(\"@string_double_raw_token__id__\")\n                }\n            ],\n            // For a comment in an expression\n            // ${ 1 + <#-- comment --> 2}\n            [s(\"expressionComment__id__\")]: [\n                {\n                    include: s(\"@expression_comment_token__id__\")\n                }\n            ],\n            // For <#noparse> ... </#noparse>\n            // For <#noParse> ... </#noParse>\n            // For <#comment> ... </#comment>\n            [s(\"noParse__id__\")]: [\n                {\n                    include: s(\"@no_parse_token__id__\")\n                }\n            ],\n            // For <#-- ... -->\n            [s(\"terseComment__id__\")]: [\n                {\n                    include: s(\"@terse_comment_token__id__\")\n                }\n            ],\n            // Common rules\n            [s(\"directive_token__id__\")]: [\n                // <ATTEMPT : <START_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <RECOVER : <START_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <SEP : <START_TAG> \"sep\" <CLOSE_TAG1>>\n                // <AUTOESC : <START_TAG> \"auto\" (\"e\"|\"E\") \"sc\" <CLOSE_TAG1>> {\n                //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n                // }\n                // <NOAUTOESC : <START_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n                //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n                // }\n                // <COMPRESS : <START_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <DEFAUL : <START_TAG> \"default\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <NOESCAPE : <START_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n                //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n                // }\n                //\n                // <COMMENT : <START_TAG> \"comment\" <CLOSE_TAG1>> {\n                //     handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); noparseTag = \"comment\";\n                // }\n                // <NOPARSE: <START_TAG> \"no\" (\"p\" | \"P\") \"arse\" <CLOSE_TAG1>> {\n                //     int tagNamingConvention = getTagNamingConvention(matchedToken, 2);\n                //     handleTagSyntaxAndSwitch(matchedToken, tagNamingConvention, NO_PARSE);\n                //     noparseTag = tagNamingConvention == Configuration.CAMEL_CASE_NAMING_CONVENTION ? \"noParse\" : \"noparse\";\n                // }\n                [\n                    r(/(?:@startTag__id__)(@directiveStartCloseTag1)(?:@closeTag1__id__)/),\n                    ts.id === \"auto\" ? {\n                        cases: {\n                            \"$1==<\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_angle_${is.id}`\n                            },\n                            \"$1==[\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_bracket_${is.id}`\n                            }\n                        }\n                    } : [\n                        {\n                            token: \"@brackets.directive\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            cases: {\n                                \"@noParseTags\": {\n                                    token: \"tag\",\n                                    next: s(\"@noParse__id__.$3\")\n                                },\n                                \"@default\": {\n                                    token: \"tag\"\n                                }\n                            }\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"@brackets.directive\"\n                        }\n                    ]\n                ],\n                // <ELSE : <START_TAG> \"else\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <BREAK : <START_TAG> \"break\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <CONTINUE : <START_TAG> \"continue\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <SIMPLE_RETURN : <START_TAG> \"return\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <HALT : <START_TAG> \"stop\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <FLUSH : <START_TAG> \"flush\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <TRIM : <START_TAG> \"t\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <LTRIM : <START_TAG> \"lt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <RTRIM : <START_TAG> \"rt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <NOTRIM : <START_TAG> \"nt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <SIMPLE_NESTED : <START_TAG> \"nested\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <SIMPLE_RECURSE : <START_TAG> \"recurse\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <FALLBACK : <START_TAG> \"fallback\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <TRIVIAL_FTL_HEADER : (\"<#ftl\" | \"[#ftl\") (\"/\")? (\">\" | \"]\")> { ftlHeader(matchedToken); }\n                [\n                    r(/(?:@startTag__id__)(@directiveStartCloseTag2)(?:@closeTag2__id__)/),\n                    ts.id === \"auto\" ? {\n                        cases: {\n                            \"$1==<\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_angle_${is.id}`\n                            },\n                            \"$1==[\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_bracket_${is.id}`\n                            }\n                        }\n                    } : [\n                        {\n                            token: \"@brackets.directive\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"tag\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"@brackets.directive\"\n                        }\n                    ]\n                ],\n                // <IF : <START_TAG> \"if\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <ELSE_IF : <START_TAG> \"else\" (\"i\" | \"I\") \"f\" <BLANK>> {\n                // \thandleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), FM_EXPRESSION);\n                // }\n                // <LIST : <START_TAG> \"list\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <FOREACH : <START_TAG> \"for\" (\"e\" | \"E\") \"ach\" <BLANK>> {\n                //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), FM_EXPRESSION);\n                // }\n                // <SWITCH : <START_TAG> \"switch\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <CASE : <START_TAG> \"case\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <ASSIGN : <START_TAG> \"assign\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <GLOBALASSIGN : <START_TAG> \"global\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <LOCALASSIGN : <START_TAG> \"local\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <_INCLUDE : <START_TAG> \"include\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <IMPORT : <START_TAG> \"import\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <FUNCTION : <START_TAG> \"function\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <MACRO : <START_TAG> \"macro\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <TRANSFORM : <START_TAG> \"transform\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <VISIT : <START_TAG> \"visit\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <STOP : <START_TAG> \"stop\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <RETURN : <START_TAG> \"return\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <CALL : <START_TAG> \"call\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <SETTING : <START_TAG> \"setting\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <OUTPUTFORMAT : <START_TAG> \"output\" (\"f\"|\"F\") \"ormat\" <BLANK>> {\n                //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), FM_EXPRESSION);\n                // }\n                // <NESTED : <START_TAG> \"nested\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <RECURSE : <START_TAG> \"recurse\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                // <ESCAPE : <START_TAG> \"escape\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                //\n                // Note: FreeMarker grammar appears to treat the FTL header as a special case,\n                // in order to remove new lines after the header (?), but since we only need\n                // to tokenize for highlighting, we can include this directive here.\n                // <FTL_HEADER : (\"<#ftl\" | \"[#ftl\") <BLANK>> { ftlHeader(matchedToken); }\n                //\n                // Note: FreeMarker grammar appears to treat the items directive as a special case for\n                // the AST parsing process, but since we only need to tokenize, we can include this\n                // directive here.\n                // <ITEMS : <START_TAG> \"items\" (<BLANK>)+ <AS> <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n                [\n                    r(/(?:@startTag__id__)(@directiveStartBlank)(@blank)/),\n                    ts.id === \"auto\" ? {\n                        cases: {\n                            \"$1==<\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_angle_${is.id}`\n                            },\n                            \"$1==[\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_bracket_${is.id}`\n                            }\n                        }\n                    } : [\n                        {\n                            token: \"@brackets.directive\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"tag\"\n                        },\n                        {\n                            token: \"\",\n                            next: s(\"@fmExpression__id__.directive\")\n                        }\n                    ]\n                ],\n                // <END_IF : <END_TAG> \"if\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_LIST : <END_TAG> \"list\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_SEP : <END_TAG> \"sep\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_RECOVER : <END_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_ATTEMPT : <END_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_FOREACH : <END_TAG> \"for\" (\"e\" | \"E\") \"ach\" <CLOSE_TAG1>> {\n                //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), DEFAULT);\n                // }\n                // <END_LOCAL : <END_TAG> \"local\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_GLOBAL : <END_TAG> \"global\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_ASSIGN : <END_TAG> \"assign\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_FUNCTION : <END_TAG> \"function\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_MACRO : <END_TAG> \"macro\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_OUTPUTFORMAT : <END_TAG> \"output\" (\"f\" | \"F\") \"ormat\" <CLOSE_TAG1>> {\n                //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), DEFAULT);\n                // }\n                // <END_AUTOESC : <END_TAG> \"auto\" (\"e\" | \"E\") \"sc\" <CLOSE_TAG1>> {\n                //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n                // }\n                // <END_NOAUTOESC : <END_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n                //   handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n                // }\n                // <END_COMPRESS : <END_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_TRANSFORM : <END_TAG> \"transform\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_SWITCH : <END_TAG> \"switch\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_ESCAPE : <END_TAG> \"escape\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n                // <END_NOESCAPE : <END_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n                //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n                // }\n                [\n                    r(/(?:@endTag__id__)(@directiveEndCloseTag1)(?:@closeTag1__id__)/),\n                    ts.id === \"auto\" ? {\n                        cases: {\n                            \"$1==<\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_angle_${is.id}`\n                            },\n                            \"$1==[\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_bracket_${is.id}`\n                            }\n                        }\n                    } : [\n                        {\n                            token: \"@brackets.directive\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"tag\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"@brackets.directive\"\n                        }\n                    ]\n                ],\n                // <UNIFIED_CALL : \"<@\" | \"[@\" > { unifiedCall(matchedToken); }\n                [\n                    r(/(@open__id__)(@)/),\n                    ts.id === \"auto\" ? {\n                        cases: {\n                            \"$1==<\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_angle_${is.id}`\n                            },\n                            \"$1==[\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_bracket_${is.id}`\n                            }\n                        }\n                    } : [\n                        {\n                            token: \"@brackets.directive\"\n                        },\n                        {\n                            token: \"delimiter.directive\",\n                            next: s(\"@unifiedCall__id__\")\n                        }\n                    ]\n                ],\n                // <UNIFIED_CALL_END : (\"<\" | \"[\") \"/@\" ((<ID>) (\".\"<ID>)*)? <CLOSE_TAG1>> { unifiedCallEnd(matchedToken); }\n                [\n                    r(/(@open__id__)(\\/@)((?:(?:@id)(?:\\.(?:@id))*)?)(?:@closeTag1__id__)/),\n                    [\n                        {\n                            token: \"@brackets.directive\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"tag\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"@brackets.directive\"\n                        }\n                    ]\n                ],\n                // <TERSE_COMMENT : (\"<\" | \"[\") \"#--\" > { noparseTag = \"-->\"; handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); }\n                [\n                    r(/(@open__id__)#--/),\n                    ts.id === \"auto\" ? {\n                        cases: {\n                            \"$1==<\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_angle_${is.id}`\n                            },\n                            \"$1==[\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_bracket_${is.id}`\n                            }\n                        }\n                    } : {\n                        token: \"comment\",\n                        next: s(\"@terseComment__id__\")\n                    }\n                ],\n                // <UNKNOWN_DIRECTIVE : (\"[#\" | \"[/#\" | \"<#\" | \"</#\") ([\"a\"-\"z\", \"A\"-\"Z\", \"_\"])+>\n                [\n                    r(/(?:@startOrEndTag__id__)([a-zA-Z_]+)/),\n                    ts.id === \"auto\" ? {\n                        cases: {\n                            \"$1==<\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_angle_${is.id}`\n                            },\n                            \"$1==[\": {\n                                token: \"@rematch\",\n                                switchTo: `@default_bracket_${is.id}`\n                            }\n                        }\n                    } : [\n                        {\n                            token: \"@brackets.directive\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"tag.invalid\",\n                            next: s(\"@fmExpression__id__.directive\")\n                        }\n                    ]\n                ]\n            ],\n            // <DEFAULT, NO_DIRECTIVE> TOKEN :\n            [s(\"interpolation_and_text_token__id__\")]: [\n                // <DOLLAR_INTERPOLATION_OPENING : \"${\"> { startInterpolation(matchedToken); }\n                // <SQUARE_BRACKET_INTERPOLATION_OPENING : \"[=\"> { startInterpolation(matchedToken); }\n                [\n                    r(/(@iOpen1__id__)(@iOpen2__id__)/),\n                    [\n                        {\n                            token: is.id === \"bracket\" ? \"@brackets.interpolation\" : \"delimiter.interpolation\"\n                        },\n                        {\n                            token: is.id === \"bracket\" ? \"delimiter.interpolation\" : \"@brackets.interpolation\",\n                            next: s(\"@fmExpression__id__.interpolation\")\n                        }\n                    ]\n                ],\n                // <STATIC_TEXT_FALSE_ALARM : \"$\" | \"#\" | \"<\" | \"[\" | \"{\"> // to handle a lone dollar sign or \"<\" or \"# or <@ with whitespace after\"\n                // <STATIC_TEXT_WS : (\"\\n\" | \"\\r\" | \"\\t\" | \" \")+>\n                // <STATIC_TEXT_NON_WS : (~[\"$\", \"<\", \"#\", \"[\", \"{\", \"\\n\", \"\\r\", \"\\t\", \" \"])+>\n                [\n                    /[\\$#<\\[\\{]|(?:@blank)+|[^\\$<#\\[\\{\\n\\r\\t ]+/,\n                    {\n                        token: \"source\"\n                    }\n                ]\n            ],\n            // <STRING_LITERAL :\n            // \t(\n            // \t\t\"\\\"\"\n            // \t\t((~[\"\\\"\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n            // \t\t\"\\\"\"\n            // \t)\n            // \t|\n            // \t(\n            // \t\t\"'\"\n            // \t\t((~[\"'\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n            // \t\t\"'\"\n            // \t)\n            // >\n            [s(\"string_single_token__id__\")]: [\n                [\n                    /[^'\\\\]/,\n                    {\n                        token: \"string\"\n                    }\n                ],\n                [\n                    /@escapedChar/,\n                    {\n                        token: \"string.escape\"\n                    }\n                ],\n                [\n                    /'/,\n                    {\n                        token: \"string\",\n                        next: \"@pop\"\n                    }\n                ]\n            ],\n            [s(\"string_double_token__id__\")]: [\n                [\n                    /[^\"\\\\]/,\n                    {\n                        token: \"string\"\n                    }\n                ],\n                [\n                    /@escapedChar/,\n                    {\n                        token: \"string.escape\"\n                    }\n                ],\n                [\n                    /\"/,\n                    {\n                        token: \"string\",\n                        next: \"@pop\"\n                    }\n                ]\n            ],\n            // <RAW_STRING : \"r\" ((\"\\\"\" (~[\"\\\"\"])* \"\\\"\") | (\"'\" (~[\"'\"])* \"'\"))>\n            [s(\"string_single_raw_token__id__\")]: [\n                [\n                    /[^']+/,\n                    {\n                        token: \"string.raw\"\n                    }\n                ],\n                [\n                    /'/,\n                    {\n                        token: \"string.raw\",\n                        next: \"@pop\"\n                    }\n                ]\n            ],\n            [s(\"string_double_raw_token__id__\")]: [\n                [\n                    /[^\"]+/,\n                    {\n                        token: \"string.raw\"\n                    }\n                ],\n                [\n                    /\"/,\n                    {\n                        token: \"string.raw\",\n                        next: \"@pop\"\n                    }\n                ]\n            ],\n            // <FM_EXPRESSION, IN_PAREN, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n            [s(\"expression_token__id__\")]: [\n                // Strings\n                [\n                    /(r?)(['\"])/,\n                    {\n                        cases: {\n                            \"r'\": [\n                                {\n                                    token: \"keyword\"\n                                },\n                                {\n                                    token: \"string.raw\",\n                                    next: s(\"@rawSingleString__id__\")\n                                }\n                            ],\n                            'r\"': [\n                                {\n                                    token: \"keyword\"\n                                },\n                                {\n                                    token: \"string.raw\",\n                                    next: s(\"@rawDoubleString__id__\")\n                                }\n                            ],\n                            \"'\": [\n                                {\n                                    token: \"source\"\n                                },\n                                {\n                                    token: \"string\",\n                                    next: s(\"@singleString__id__\")\n                                }\n                            ],\n                            '\"': [\n                                {\n                                    token: \"source\"\n                                },\n                                {\n                                    token: \"string\",\n                                    next: s(\"@doubleString__id__\")\n                                }\n                            ]\n                        }\n                    }\n                ],\n                // Numbers\n                // <INTEGER : ([\"0\"-\"9\"])+>\n                // <DECIMAL : <INTEGER> \".\" <INTEGER>>\n                [\n                    /(?:@integer)(?:\\.(?:@integer))?/,\n                    {\n                        cases: {\n                            \"(?:@integer)\": {\n                                token: \"number\"\n                            },\n                            \"@default\": {\n                                token: \"number.float\"\n                            }\n                        }\n                    }\n                ],\n                // Special hash keys that must not be treated as identifiers\n                // after a period, e.g. a.** is accessing the key \"**\" of a\n                [\n                    /(\\.)(@blank*)(@specialHashKeys)/,\n                    [\n                        {\n                            token: \"delimiter\"\n                        },\n                        {\n                            token: \"\"\n                        },\n                        {\n                            token: \"identifier\"\n                        }\n                    ]\n                ],\n                // Symbols / operators\n                [\n                    /(?:@namedSymbols)/,\n                    {\n                        cases: {\n                            \"@arrows\": {\n                                token: \"meta.arrow\"\n                            },\n                            \"@delimiters\": {\n                                token: \"delimiter\"\n                            },\n                            \"@default\": {\n                                token: \"operators\"\n                            }\n                        }\n                    }\n                ],\n                // Identifiers\n                [\n                    /@id/,\n                    {\n                        cases: {\n                            \"@keywords\": {\n                                token: \"keyword.$0\"\n                            },\n                            \"@stringOperators\": {\n                                token: \"operators\"\n                            },\n                            \"@default\": {\n                                token: \"identifier\"\n                            }\n                        }\n                    }\n                ],\n                // <OPEN_BRACKET : \"[\">\n                // <CLOSE_BRACKET : \"]\">\n                // <OPEN_PAREN : \"(\">\n                // <CLOSE_PAREN : \")\">\n                // <OPENING_CURLY_BRACKET : \"{\">\n                // <CLOSING_CURLY_BRACKET : \"}\">\n                [\n                    /[\\[\\]\\(\\)\\{\\}]/,\n                    {\n                        cases: {\n                            \"\\\\[\": {\n                                cases: {\n                                    \"$S2==gt\": {\n                                        token: \"@brackets\",\n                                        next: s(\"@inParen__id__.gt\")\n                                    },\n                                    \"@default\": {\n                                        token: \"@brackets\",\n                                        next: s(\"@inParen__id__.plain\")\n                                    }\n                                }\n                            },\n                            \"\\\\]\": {\n                                cases: {\n                                    ...is.id === \"bracket\" ? {\n                                        \"$S2==interpolation\": {\n                                            token: \"@brackets.interpolation\",\n                                            next: \"@popall\"\n                                        }\n                                    } : {},\n                                    // This cannot happen while in auto mode, since this applies only to an\n                                    // fmExpression inside a directive. But once we encounter the start of a\n                                    // directive, we can establish the tag syntax mode.\n                                    ...ts.id === \"bracket\" ? {\n                                        \"$S2==directive\": {\n                                            token: \"@brackets.directive\",\n                                            next: \"@popall\"\n                                        }\n                                    } : {},\n                                    // Ignore mismatched paren\n                                    [s(\"$S1==inParen__id__\")]: {\n                                        token: \"@brackets\",\n                                        next: \"@pop\"\n                                    },\n                                    \"@default\": {\n                                        token: \"@brackets\"\n                                    }\n                                }\n                            },\n                            \"\\\\(\": {\n                                token: \"@brackets\",\n                                next: s(\"@inParen__id__.gt\")\n                            },\n                            \"\\\\)\": {\n                                cases: {\n                                    [s(\"$S1==inParen__id__\")]: {\n                                        token: \"@brackets\",\n                                        next: \"@pop\"\n                                    },\n                                    \"@default\": {\n                                        token: \"@brackets\"\n                                    }\n                                }\n                            },\n                            \"\\\\{\": {\n                                cases: {\n                                    \"$S2==gt\": {\n                                        token: \"@brackets\",\n                                        next: s(\"@inParen__id__.gt\")\n                                    },\n                                    \"@default\": {\n                                        token: \"@brackets\",\n                                        next: s(\"@inParen__id__.plain\")\n                                    }\n                                }\n                            },\n                            \"\\\\}\": {\n                                cases: {\n                                    ...is.id === \"bracket\" ? {} : {\n                                        \"$S2==interpolation\": {\n                                            token: \"@brackets.interpolation\",\n                                            next: \"@popall\"\n                                        }\n                                    },\n                                    // Ignore mismatched paren\n                                    [s(\"$S1==inParen__id__\")]: {\n                                        token: \"@brackets\",\n                                        next: \"@pop\"\n                                    },\n                                    \"@default\": {\n                                        token: \"@brackets\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                ],\n                // <OPEN_MISPLACED_INTERPOLATION : \"${\" | \"#{\" | \"[=\">\n                [\n                    /\\$\\{/,\n                    {\n                        token: \"delimiter.invalid\"\n                    }\n                ]\n            ],\n            // <FM_EXPRESSION, IN_PAREN, NAMED_PARAMETER_EXPRESSION> SKIP :\n            [s(\"blank_and_expression_comment_token__id__\")]: [\n                // < ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )+ >\n                [\n                    /(?:@blank)+/,\n                    {\n                        token: \"\"\n                    }\n                ],\n                // < (\"<\" | \"[\") (\"#\" | \"!\") \"--\"> : EXPRESSION_COMMENT\n                [\n                    /[<\\[][#!]--/,\n                    {\n                        token: \"comment\",\n                        next: s(\"@expressionComment__id__\")\n                    }\n                ]\n            ],\n            // <FM_EXPRESSION, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n            [s(\"directive_end_token__id__\")]: [\n                // <DIRECTIVE_END : \">\">\n                // {\n                //     if (inFTLHeader) {\n                //         eatNewline();\n                //         inFTLHeader = false;\n                //     }\n                //     if (squBracTagSyntax || postInterpolationLexState != -1 /* We are in an interpolation */) {\n                //         matchedToken.kind = NATURAL_GT;\n                //     } else {\n                //         SwitchTo(DEFAULT);\n                //     }\n                // }\n                // This cannot happen while in auto mode, since this applies only to an\n                // fmExpression inside a directive. But once we encounter the start of a\n                // directive, we can establish the tag syntax mode.\n                [\n                    />/,\n                    ts.id === \"bracket\" ? {\n                        token: \"operators\"\n                    } : {\n                        token: \"@brackets.directive\",\n                        next: \"@popall\"\n                    }\n                ],\n                // <EMPTY_DIRECTIVE_END : \"/>\" | \"/]\">\n                // It is a syntax error to end a tag with the wrong close token\n                // Let's indicate that to the user by not closing the tag\n                [\n                    r(/(\\/)(@close__id__)/),\n                    [\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"@brackets.directive\",\n                            next: \"@popall\"\n                        }\n                    ]\n                ]\n            ],\n            // <IN_PAREN> TOKEN :\n            [s(\"greater_operators_token__id__\")]: [\n                // <NATURAL_GT : \">\">\n                [\n                    />/,\n                    {\n                        token: \"operators\"\n                    }\n                ],\n                // <NATURAL_GTE : \">=\">\n                [\n                    />=/,\n                    {\n                        token: \"operators\"\n                    }\n                ]\n            ],\n            // <NO_SPACE_EXPRESSION> TOKEN :\n            [s(\"no_space_expression_end_token__id__\")]: [\n                // <TERMINATING_WHITESPACE :  ([\"\\n\", \"\\r\", \"\\t\", \" \"])+> : FM_EXPRESSION\n                [\n                    /(?:@blank)+/,\n                    {\n                        token: \"\",\n                        switchTo: s(\"@fmExpression__id__.directive\")\n                    }\n                ]\n            ],\n            [s(\"unified_call_token__id__\")]: [\n                // Special case for a call where the expression is just an ID\n                // <UNIFIED_CALL> <ID> <BLANK>+\n                [\n                    /(@id)((?:@blank)+)/,\n                    [\n                        {\n                            token: \"tag\"\n                        },\n                        {\n                            token: \"\",\n                            next: s(\"@fmExpression__id__.directive\")\n                        }\n                    ]\n                ],\n                [\n                    r(/(@id)(\\/?)(@close__id__)/),\n                    [\n                        {\n                            token: \"tag\"\n                        },\n                        {\n                            token: \"delimiter.directive\"\n                        },\n                        {\n                            token: \"@brackets.directive\",\n                            next: \"@popall\"\n                        }\n                    ]\n                ],\n                [\n                    /./,\n                    {\n                        token: \"@rematch\",\n                        next: s(\"@noSpaceExpression__id__\")\n                    }\n                ]\n            ],\n            // <NO_PARSE> TOKEN :\n            [s(\"no_parse_token__id__\")]: [\n                // <MAYBE_END :\n                // \t (\"<\" | \"[\")\n                // \t \"/\"\n                // \t (\"#\")?\n                // \t ([\"a\"-\"z\", \"A\"-\"Z\"])+\n                // \t ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )*\n                // \t (\">\" | \"]\")\n                // >\n                [\n                    r(/(@open__id__)(\\/#?)([a-zA-Z]+)((?:@blank)*)(@close__id__)/),\n                    {\n                        cases: {\n                            \"$S2==$3\": [\n                                {\n                                    token: \"@brackets.directive\"\n                                },\n                                {\n                                    token: \"delimiter.directive\"\n                                },\n                                {\n                                    token: \"tag\"\n                                },\n                                {\n                                    token: \"\"\n                                },\n                                {\n                                    token: \"@brackets.directive\",\n                                    next: \"@popall\"\n                                }\n                            ],\n                            \"$S2==comment\": [\n                                {\n                                    token: \"comment\"\n                                },\n                                {\n                                    token: \"comment\"\n                                },\n                                {\n                                    token: \"comment\"\n                                },\n                                {\n                                    token: \"comment\"\n                                },\n                                {\n                                    token: \"comment\"\n                                }\n                            ],\n                            \"@default\": [\n                                {\n                                    token: \"source\"\n                                },\n                                {\n                                    token: \"source\"\n                                },\n                                {\n                                    token: \"source\"\n                                },\n                                {\n                                    token: \"source\"\n                                },\n                                {\n                                    token: \"source\"\n                                }\n                            ]\n                        }\n                    }\n                ],\n                // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n                // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n                [\n                    /[^<\\[\\-]+|[<\\[\\-]/,\n                    {\n                        cases: {\n                            \"$S2==comment\": {\n                                token: \"comment\"\n                            },\n                            \"@default\": {\n                                token: \"source\"\n                            }\n                        }\n                    }\n                ]\n            ],\n            // <EXPRESSION_COMMENT> SKIP:\n            [s(\"expression_comment_token__id__\")]: [\n                // < \"-->\" | \"--]\">\n                [\n                    /--[>\\]]/,\n                    {\n                        token: \"comment\",\n                        next: \"@pop\"\n                    }\n                ],\n                // < (~[\"-\", \">\", \"]\"])+ >\n                // < \">\">\n                // < \"]\">\n                // < \"-\">\n                [\n                    /[^\\->\\]]+|[>\\]\\-]/,\n                    {\n                        token: \"comment\"\n                    }\n                ]\n            ],\n            [s(\"terse_comment_token__id__\")]: [\n                //  <TERSE_COMMENT_END : \"-->\" | \"--]\">\n                [\n                    r(/--(?:@close__id__)/),\n                    {\n                        token: \"comment\",\n                        next: \"@popall\"\n                    }\n                ],\n                // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n                // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n                [\n                    /[^<\\[\\-]+|[<\\[\\-]/,\n                    {\n                        token: \"comment\"\n                    }\n                ]\n            ]\n        }\n    };\n}\nfunction $181d7191d7e7a5bf$var$createMonarchLanguageAuto(is) {\n    const angle = $181d7191d7e7a5bf$var$createMonarchLanguage($181d7191d7e7a5bf$var$TagSyntaxAngle, is);\n    const bracket = $181d7191d7e7a5bf$var$createMonarchLanguage($181d7191d7e7a5bf$var$TagSyntaxBracket, is);\n    const auto = $181d7191d7e7a5bf$var$createMonarchLanguage($181d7191d7e7a5bf$var$TagSyntaxAuto, is);\n    return {\n        // Angle and bracket syntax mode\n        // We switch to one of these once we have determined the mode\n        ...angle,\n        ...bracket,\n        ...auto,\n        // Settings\n        unicode: true,\n        includeLF: false,\n        start: `default_auto_${is.id}`,\n        ignoreCase: false,\n        defaultToken: \"invalid\",\n        tokenPostfix: `.freemarker2`,\n        brackets: [\n            {\n                open: \"{\",\n                close: \"}\",\n                token: \"delimiter.curly\"\n            },\n            {\n                open: \"[\",\n                close: \"]\",\n                token: \"delimiter.square\"\n            },\n            {\n                open: \"(\",\n                close: \")\",\n                token: \"delimiter.parenthesis\"\n            },\n            {\n                open: \"<\",\n                close: \">\",\n                token: \"delimiter.angle\"\n            }\n        ],\n        tokenizer: {\n            ...angle.tokenizer,\n            ...bracket.tokenizer,\n            ...auto.tokenizer\n        }\n    };\n}\nvar $181d7191d7e7a5bf$export$9945f5d7c02ad2fc = {\n    conf: $181d7191d7e7a5bf$var$createLangConfiguration($181d7191d7e7a5bf$var$TagSyntaxAngle),\n    language: $181d7191d7e7a5bf$var$createMonarchLanguage($181d7191d7e7a5bf$var$TagSyntaxAngle, $181d7191d7e7a5bf$var$InterpolationSyntaxDollar)\n};\nvar $181d7191d7e7a5bf$export$6f4f6c4e91d5ee59 = {\n    conf: $181d7191d7e7a5bf$var$createLangConfiguration($181d7191d7e7a5bf$var$TagSyntaxBracket),\n    language: $181d7191d7e7a5bf$var$createMonarchLanguage($181d7191d7e7a5bf$var$TagSyntaxBracket, $181d7191d7e7a5bf$var$InterpolationSyntaxDollar)\n};\nvar $181d7191d7e7a5bf$export$1cb623f6377415e8 = {\n    conf: $181d7191d7e7a5bf$var$createLangConfiguration($181d7191d7e7a5bf$var$TagSyntaxAngle),\n    language: $181d7191d7e7a5bf$var$createMonarchLanguage($181d7191d7e7a5bf$var$TagSyntaxAngle, $181d7191d7e7a5bf$var$InterpolationSyntaxBracket)\n};\nvar $181d7191d7e7a5bf$export$d0605717f8750fe2 = {\n    conf: $181d7191d7e7a5bf$var$createLangConfiguration($181d7191d7e7a5bf$var$TagSyntaxBracket),\n    language: $181d7191d7e7a5bf$var$createMonarchLanguage($181d7191d7e7a5bf$var$TagSyntaxBracket, $181d7191d7e7a5bf$var$InterpolationSyntaxBracket)\n};\nvar $181d7191d7e7a5bf$export$b685ef20e1dddf83 = {\n    conf: $181d7191d7e7a5bf$var$createLangConfigurationAuto(),\n    language: $181d7191d7e7a5bf$var$createMonarchLanguageAuto($181d7191d7e7a5bf$var$InterpolationSyntaxDollar)\n};\nvar $181d7191d7e7a5bf$export$d2238c7b2ec81a45 = {\n    conf: $181d7191d7e7a5bf$var$createLangConfigurationAuto(),\n    language: $181d7191d7e7a5bf$var$createMonarchLanguageAuto($181d7191d7e7a5bf$var$InterpolationSyntaxBracket)\n};\n\n});\n\n\n//# sourceMappingURL=freemarker2.2650a4f7.js.map\n","/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.48.0(0037b13fb5d186fdf1e7df51a9416a2de2b8c670)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/basic-languages/freemarker2/freemarker2.ts\nvar EMPTY_ELEMENTS = [\n  \"assign\",\n  \"flush\",\n  \"ftl\",\n  \"return\",\n  \"global\",\n  \"import\",\n  \"include\",\n  \"break\",\n  \"continue\",\n  \"local\",\n  \"nested\",\n  \"nt\",\n  \"setting\",\n  \"stop\",\n  \"t\",\n  \"lt\",\n  \"rt\",\n  \"fallback\"\n];\nvar BLOCK_ELEMENTS = [\n  \"attempt\",\n  \"autoesc\",\n  \"autoEsc\",\n  \"compress\",\n  \"comment\",\n  \"escape\",\n  \"noescape\",\n  \"function\",\n  \"if\",\n  \"list\",\n  \"items\",\n  \"sep\",\n  \"macro\",\n  \"noparse\",\n  \"noParse\",\n  \"noautoesc\",\n  \"noAutoEsc\",\n  \"outputformat\",\n  \"switch\",\n  \"visit\",\n  \"recurse\"\n];\nvar TagSyntaxAngle = {\n  close: \">\",\n  id: \"angle\",\n  open: \"<\"\n};\nvar TagSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open: \"\\\\[\"\n};\nvar TagSyntaxAuto = {\n  close: \"[>\\\\]]\",\n  id: \"auto\",\n  open: \"[<\\\\[]\"\n};\nvar InterpolationSyntaxDollar = {\n  close: \"\\\\}\",\n  id: \"dollar\",\n  open1: \"\\\\$\",\n  open2: \"\\\\{\"\n};\nvar InterpolationSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open1: \"\\\\[\",\n  open2: \"=\"\n};\nfunction createLangConfiguration(ts) {\n  return {\n    brackets: [\n      [\"<\", \">\"],\n      [\"[\", \"]\"],\n      [\"(\", \")\"],\n      [\"{\", \"}\"]\n    ],\n    comments: {\n      blockComment: [`${ts.open}--`, `--${ts.close}`]\n    },\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: '\"', close: '\"', notIn: [\"string\"] },\n      { open: \"'\", close: \"'\", notIn: [\"string\"] }\n    ],\n    surroundingPairs: [\n      { open: '\"', close: '\"' },\n      { open: \"'\", close: \"'\" },\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: \"<\", close: \">\" }\n    ],\n    folding: {\n      markers: {\n        start: new RegExp(\n          `${ts.open}#(?:${BLOCK_ELEMENTS.join(\"|\")})([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`\n        ),\n        end: new RegExp(`${ts.open}/#(?:${BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n      }\n    },\n    onEnterRules: [\n      {\n        beforeText: new RegExp(\n          `${ts.open}#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`\n        ),\n        afterText: new RegExp(`^${ts.open}/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*${ts.close}$`),\n        action: {\n          indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n        }\n      },\n      {\n        beforeText: new RegExp(\n          `${ts.open}#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`\n        ),\n        action: { indentAction: monaco_editor_core_exports.languages.IndentAction.Indent }\n      }\n    ]\n  };\n}\nfunction createLangConfigurationAuto() {\n  return {\n    // Cannot set block comment delimiter in auto mode...\n    // It depends on the content and the cursor position of the file...\n    brackets: [\n      [\"<\", \">\"],\n      [\"[\", \"]\"],\n      [\"(\", \")\"],\n      [\"{\", \"}\"]\n    ],\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: '\"', close: '\"', notIn: [\"string\"] },\n      { open: \"'\", close: \"'\", notIn: [\"string\"] }\n    ],\n    surroundingPairs: [\n      { open: '\"', close: '\"' },\n      { open: \"'\", close: \"'\" },\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: \"<\", close: \">\" }\n    ],\n    folding: {\n      markers: {\n        start: new RegExp(`[<\\\\[]#(?:${BLOCK_ELEMENTS.join(\"|\")})([^/>\\\\]]*(?!/)[>\\\\]])[^<\\\\[]*$`),\n        end: new RegExp(`[<\\\\[]/#(?:${BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n      }\n    },\n    onEnterRules: [\n      {\n        beforeText: new RegExp(\n          `[<\\\\[]#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`\n        ),\n        afterText: new RegExp(`^[<\\\\[]/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*[>\\\\]]$`),\n        action: {\n          indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n        }\n      },\n      {\n        beforeText: new RegExp(\n          `[<\\\\[]#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`\n        ),\n        action: { indentAction: monaco_editor_core_exports.languages.IndentAction.Indent }\n      }\n    ]\n  };\n}\nfunction createMonarchLanguage(ts, is) {\n  const id = `_${ts.id}_${is.id}`;\n  const s = (name) => name.replace(/__id__/g, id);\n  const r = (regexp) => {\n    const source = regexp.source.replace(/__id__/g, id);\n    return new RegExp(source, regexp.flags);\n  };\n  return {\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: s(\"default__id__\"),\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: `.freemarker2`,\n    brackets: [\n      { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n      { open: \"[\", close: \"]\", token: \"delimiter.square\" },\n      { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n      { open: \"<\", close: \">\", token: \"delimiter.angle\" }\n    ],\n    // Dynamic RegExp\n    [s(\"open__id__\")]: new RegExp(ts.open),\n    [s(\"close__id__\")]: new RegExp(ts.close),\n    [s(\"iOpen1__id__\")]: new RegExp(is.open1),\n    [s(\"iOpen2__id__\")]: new RegExp(is.open2),\n    [s(\"iClose__id__\")]: new RegExp(is.close),\n    // <#START_TAG : \"<\" | \"<#\" | \"[#\">\n    // <#END_TAG : \"</\" | \"</#\" | \"[/#\">\n    [s(\"startTag__id__\")]: r(/(@open__id__)(#)/),\n    [s(\"endTag__id__\")]: r(/(@open__id__)(\\/#)/),\n    [s(\"startOrEndTag__id__\")]: r(/(@open__id__)(\\/?#)/),\n    // <#CLOSE_TAG1 : (<BLANK>)* (\">\" | \"]\")>\n    [s(\"closeTag1__id__\")]: r(/((?:@blank)*)(@close__id__)/),\n    // <#CLOSE_TAG2 : (<BLANK>)* (\"/\")? (\">\" | \"]\")>\n    [s(\"closeTag2__id__\")]: r(/((?:@blank)*\\/?)(@close__id__)/),\n    // Static RegExp\n    // <#BLANK : \" \" | \"\\t\" | \"\\n\" | \"\\r\">\n    blank: /[ \\t\\n\\r]/,\n    // <FALSE : \"false\">\n    // <TRUE : \"true\">\n    // <IN : \"in\">\n    // <AS : \"as\">\n    // <USING : \"using\">\n    keywords: [\"false\", \"true\", \"in\", \"as\", \"using\"],\n    // Directive names that cannot have an expression parameters and cannot be self-closing\n    // E.g. <#if id==2> ... </#if>\n    directiveStartCloseTag1: /attempt|recover|sep|auto[eE]sc|no(?:autoe|AutoE)sc|compress|default|no[eE]scape|comment|no[pP]arse/,\n    // Directive names that cannot have an expression parameter and can be self-closing\n    // E.g. <#if> ... <#else>  ... </#if>\n    // E.g. <#if> ... <#else /></#if>\n    directiveStartCloseTag2: /else|break|continue|return|stop|flush|t|lt|rt|nt|nested|recurse|fallback|ftl/,\n    // Directive names that can have an expression parameter and cannot be self-closing\n    // E.g. <#if id==2> ... </#if>\n    directiveStartBlank: /if|else[iI]f|list|for[eE]ach|switch|case|assign|global|local|include|import|function|macro|transform|visit|stop|return|call|setting|output[fF]ormat|nested|recurse|escape|ftl|items/,\n    // Directive names that can have an end tag\n    // E.g. </#if>\n    directiveEndCloseTag1: /if|list|items|sep|recover|attempt|for[eE]ach|local|global|assign|function|macro|output[fF]ormat|auto[eE]sc|no(?:autoe|AutoE)sc|compress|transform|switch|escape|no[eE]scape/,\n    // <#ESCAPED_CHAR :\n    //     \"\\\\\"\n    //     (\n    //         (\"n\" | \"t\" | \"r\" | \"f\" | \"b\" | \"g\" | \"l\" | \"a\" | \"\\\\\" | \"'\" | \"\\\"\" | \"{\" | \"=\")\n    //         |\n    //         (\"x\" [\"0\"-\"9\", \"A\"-\"F\", \"a\"-\"f\"])\n    //     )\n    // >\n    // Note: While the JavaCC tokenizer rule only specifies one hex digit,\n    // FreeMarker actually interprets up to 4 hex digits.\n    escapedChar: /\\\\(?:[ntrfbgla\\\\'\"\\{=]|(?:x[0-9A-Fa-f]{1,4}))/,\n    // <#ASCII_DIGIT: [\"0\" - \"9\"]>\n    asciiDigit: /[0-9]/,\n    // <INTEGER : ([\"0\"-\"9\"])+>\n    integer: /[0-9]+/,\n    // <#NON_ESCAPED_ID_START_CHAR:\n    // [\n    // \t  // This was generated on JDK 1.8.0_20 Win64 with src/main/misc/identifierChars/IdentifierCharGenerator.java\n    //    ...\n    // ]\n    nonEscapedIdStartChar: /[\\$@-Z_a-z\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u1FFF\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183-\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3006\\u3031-\\u3035\\u303B-\\u303C\\u3040-\\u318F\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3300-\\u337F\\u3400-\\u4DB5\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n    // <#ESCAPED_ID_CHAR: \"\\\\\" (\"-\" | \".\" | \":\" | \"#\")>\n    escapedIdChar: /\\\\[\\-\\.:#]/,\n    // <#ID_START_CHAR: <NON_ESCAPED_ID_START_CHAR>|<ESCAPED_ID_CHAR>>\n    idStartChar: /(?:@nonEscapedIdStartChar)|(?:@escapedIdChar)/,\n    // <ID: <ID_START_CHAR> (<ID_START_CHAR>|<ASCII_DIGIT>)*>\n    id: /(?:@idStartChar)(?:(?:@idStartChar)|(?:@asciiDigit))*/,\n    // Certain keywords / operators are allowed to index hashes\n    //\n    // Expression DotVariable(Expression exp) :\n    // {\n    // \tToken t;\n    // }\n    // {\n    // \t\t<DOT>\n    // \t\t(\n    // \t\t\tt = <ID> | t = <TIMES> | t = <DOUBLE_STAR>\n    // \t\t\t|\n    // \t\t\t(\n    // \t\t\t\tt = <LESS_THAN>\n    // \t\t\t\t|\n    // \t\t\t\tt = <LESS_THAN_EQUALS>\n    // \t\t\t\t|\n    // \t\t\t\tt = <ESCAPED_GT>\n    // \t\t\t\t|\n    // \t\t\t\tt = <ESCAPED_GTE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <FALSE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <TRUE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <IN>\n    // \t\t\t\t|\n    // \t\t\t\tt = <AS>\n    // \t\t\t\t|\n    // \t\t\t\tt = <USING>\n    // \t\t\t)\n    // \t\t\t{\n    // \t\t\t\tif (!Character.isLetter(t.image.charAt(0))) {\n    // \t\t\t\t\tthrow new ParseException(t.image + \" is not a valid identifier.\", template, t);\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t)\n    // \t\t{\n    // \t\t\tnotListLiteral(exp, \"hash\");\n    // \t\t\tnotStringLiteral(exp, \"hash\");\n    // \t\t\tnotBooleanLiteral(exp, \"hash\");\n    // \t\t\tDot dot = new Dot(exp, t.image);\n    // \t\t\tdot.setLocation(template, exp, t);\n    // \t\t\treturn dot;\n    // \t\t}\n    // }\n    specialHashKeys: /\\*\\*|\\*|false|true|in|as|using/,\n    // <DOUBLE_EQUALS : \"==\">\n    // <EQUALS : \"=\">\n    // <NOT_EQUALS : \"!=\">\n    // <PLUS_EQUALS : \"+=\">\n    // <MINUS_EQUALS : \"-=\">\n    // <TIMES_EQUALS : \"*=\">\n    // <DIV_EQUALS : \"/=\">\n    // <MOD_EQUALS : \"%=\">\n    // <PLUS_PLUS : \"++\">\n    // <MINUS_MINUS : \"--\">\n    // <LESS_THAN_EQUALS : \"lte\" | \"\\\\lte\" | \"<=\" | \"&lt;=\">\n    // <LESS_THAN : \"lt\" | \"\\\\lt\" | \"<\" | \"&lt;\">\n    // <ESCAPED_GTE : \"gte\" | \"\\\\gte\" | \"&gt;=\">\n    // <ESCAPED_GT: \"gt\" | \"\\\\gt\" |  \"&gt;\">\n    // <DOUBLE_STAR : \"**\">\n    // <PLUS : \"+\">\n    // <MINUS : \"-\">\n    // <TIMES : \"*\">\n    // <PERCENT : \"%\">\n    // <AND : \"&\" | \"&&\" | \"&amp;&amp;\" | \"\\\\and\" >\n    // <OR : \"|\" | \"||\">\n    // <EXCLAM : \"!\">\n    // <COMMA : \",\">\n    // <SEMICOLON : \";\">\n    // <COLON : \":\">\n    // <ELLIPSIS : \"...\">\n    // <DOT_DOT_ASTERISK : \"..*\" >\n    // <DOT_DOT_LESS : \"..<\" | \"..!\" >\n    // <DOT_DOT : \"..\">\n    // <EXISTS : \"??\">\n    // <BUILT_IN : \"?\">\n    // <LAMBDA_ARROW : \"->\" | \"-&gt;\">\n    namedSymbols: /&lt;=|&gt;=|\\\\lte|\\\\lt|&lt;|\\\\gte|\\\\gt|&gt;|&amp;&amp;|\\\\and|-&gt;|->|==|!=|\\+=|-=|\\*=|\\/=|%=|\\+\\+|--|<=|&&|\\|\\||:|\\.\\.\\.|\\.\\.\\*|\\.\\.<|\\.\\.!|\\?\\?|=|<|\\+|-|\\*|\\/|%|\\||\\.\\.|\\?|!|&|\\.|,|;/,\n    arrows: [\"->\", \"-&gt;\"],\n    delimiters: [\";\", \":\", \",\", \".\"],\n    stringOperators: [\"lte\", \"lt\", \"gte\", \"gt\"],\n    noParseTags: [\"noparse\", \"noParse\", \"comment\"],\n    tokenizer: {\n      // Parser states\n      // Plain text\n      [s(\"default__id__\")]: [\n        { include: s(\"@directive_token__id__\") },\n        { include: s(\"@interpolation_and_text_token__id__\") }\n      ],\n      // A FreeMarker expression inside a directive, e.g. <#if 2<3>\n      [s(\"fmExpression__id__.directive\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@directive_end_token__id__\") },\n        { include: s(\"@expression_token__id__\") }\n      ],\n      // A FreeMarker expression inside an interpolation, e.g. ${2+3}\n      [s(\"fmExpression__id__.interpolation\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@expression_token__id__\") },\n        { include: s(\"@greater_operators_token__id__\") }\n      ],\n      // In an expression and inside a not-yet closed parenthesis / bracket\n      [s(\"inParen__id__.plain\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@directive_end_token__id__\") },\n        { include: s(\"@expression_token__id__\") }\n      ],\n      [s(\"inParen__id__.gt\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@expression_token__id__\") },\n        { include: s(\"@greater_operators_token__id__\") }\n      ],\n      // Expression for the unified call, e.g. <@createMacro() ... >\n      [s(\"noSpaceExpression__id__\")]: [\n        { include: s(\"@no_space_expression_end_token__id__\") },\n        { include: s(\"@directive_end_token__id__\") },\n        { include: s(\"@expression_token__id__\") }\n      ],\n      // For the function of a unified call. Special case for when the\n      // expression is a simple identifier.\n      // <@join [1,2] \",\">\n      // <@null!join [1,2] \",\">\n      [s(\"unifiedCall__id__\")]: [{ include: s(\"@unified_call_token__id__\") }],\n      // For singly and doubly quoted string (that may contain interpolations)\n      [s(\"singleString__id__\")]: [{ include: s(\"@string_single_token__id__\") }],\n      [s(\"doubleString__id__\")]: [{ include: s(\"@string_double_token__id__\") }],\n      // For singly and doubly quoted string (that may not contain interpolations)\n      [s(\"rawSingleString__id__\")]: [{ include: s(\"@string_single_raw_token__id__\") }],\n      [s(\"rawDoubleString__id__\")]: [{ include: s(\"@string_double_raw_token__id__\") }],\n      // For a comment in an expression\n      // ${ 1 + <#-- comment --> 2}\n      [s(\"expressionComment__id__\")]: [{ include: s(\"@expression_comment_token__id__\") }],\n      // For <#noparse> ... </#noparse>\n      // For <#noParse> ... </#noParse>\n      // For <#comment> ... </#comment>\n      [s(\"noParse__id__\")]: [{ include: s(\"@no_parse_token__id__\") }],\n      // For <#-- ... -->\n      [s(\"terseComment__id__\")]: [{ include: s(\"@terse_comment_token__id__\") }],\n      // Common rules\n      [s(\"directive_token__id__\")]: [\n        // <ATTEMPT : <START_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <RECOVER : <START_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SEP : <START_TAG> \"sep\" <CLOSE_TAG1>>\n        // <AUTOESC : <START_TAG> \"auto\" (\"e\"|\"E\") \"sc\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n        // }\n        // <NOAUTOESC : <START_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        // <COMPRESS : <START_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <DEFAUL : <START_TAG> \"default\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <NOESCAPE : <START_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        //\n        // <COMMENT : <START_TAG> \"comment\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); noparseTag = \"comment\";\n        // }\n        // <NOPARSE: <START_TAG> \"no\" (\"p\" | \"P\") \"arse\" <CLOSE_TAG1>> {\n        //     int tagNamingConvention = getTagNamingConvention(matchedToken, 2);\n        //     handleTagSyntaxAndSwitch(matchedToken, tagNamingConvention, NO_PARSE);\n        //     noparseTag = tagNamingConvention == Configuration.CAMEL_CASE_NAMING_CONVENTION ? \"noParse\" : \"noparse\";\n        // }\n        [\n          r(/(?:@startTag__id__)(@directiveStartCloseTag1)(?:@closeTag1__id__)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            {\n              cases: {\n                \"@noParseTags\": { token: \"tag\", next: s(\"@noParse__id__.$3\") },\n                \"@default\": { token: \"tag\" }\n              }\n            },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <ELSE : <START_TAG> \"else\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <BREAK : <START_TAG> \"break\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <CONTINUE : <START_TAG> \"continue\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SIMPLE_RETURN : <START_TAG> \"return\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <HALT : <START_TAG> \"stop\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <FLUSH : <START_TAG> \"flush\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <TRIM : <START_TAG> \"t\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <LTRIM : <START_TAG> \"lt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <RTRIM : <START_TAG> \"rt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <NOTRIM : <START_TAG> \"nt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SIMPLE_NESTED : <START_TAG> \"nested\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SIMPLE_RECURSE : <START_TAG> \"recurse\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <FALLBACK : <START_TAG> \"fallback\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <TRIVIAL_FTL_HEADER : (\"<#ftl\" | \"[#ftl\") (\"/\")? (\">\" | \"]\")> { ftlHeader(matchedToken); }\n        [\n          r(/(?:@startTag__id__)(@directiveStartCloseTag2)(?:@closeTag2__id__)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <IF : <START_TAG> \"if\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <ELSE_IF : <START_TAG> \"else\" (\"i\" | \"I\") \"f\" <BLANK>> {\n        // \thandleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), FM_EXPRESSION);\n        // }\n        // <LIST : <START_TAG> \"list\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <FOREACH : <START_TAG> \"for\" (\"e\" | \"E\") \"ach\" <BLANK>> {\n        //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), FM_EXPRESSION);\n        // }\n        // <SWITCH : <START_TAG> \"switch\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <CASE : <START_TAG> \"case\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <ASSIGN : <START_TAG> \"assign\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <GLOBALASSIGN : <START_TAG> \"global\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <LOCALASSIGN : <START_TAG> \"local\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <_INCLUDE : <START_TAG> \"include\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <IMPORT : <START_TAG> \"import\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <FUNCTION : <START_TAG> \"function\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <MACRO : <START_TAG> \"macro\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <TRANSFORM : <START_TAG> \"transform\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <VISIT : <START_TAG> \"visit\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <STOP : <START_TAG> \"stop\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <RETURN : <START_TAG> \"return\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <CALL : <START_TAG> \"call\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <SETTING : <START_TAG> \"setting\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <OUTPUTFORMAT : <START_TAG> \"output\" (\"f\"|\"F\") \"ormat\" <BLANK>> {\n        //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), FM_EXPRESSION);\n        // }\n        // <NESTED : <START_TAG> \"nested\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <RECURSE : <START_TAG> \"recurse\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <ESCAPE : <START_TAG> \"escape\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        //\n        // Note: FreeMarker grammar appears to treat the FTL header as a special case,\n        // in order to remove new lines after the header (?), but since we only need\n        // to tokenize for highlighting, we can include this directive here.\n        // <FTL_HEADER : (\"<#ftl\" | \"[#ftl\") <BLANK>> { ftlHeader(matchedToken); }\n        //\n        // Note: FreeMarker grammar appears to treat the items directive as a special case for\n        // the AST parsing process, but since we only need to tokenize, we can include this\n        // directive here.\n        // <ITEMS : <START_TAG> \"items\" (<BLANK>)+ <AS> <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        [\n          r(/(?:@startTag__id__)(@directiveStartBlank)(@blank)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"\", next: s(\"@fmExpression__id__.directive\") }\n          ]\n        ],\n        // <END_IF : <END_TAG> \"if\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_LIST : <END_TAG> \"list\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_SEP : <END_TAG> \"sep\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_RECOVER : <END_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_ATTEMPT : <END_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_FOREACH : <END_TAG> \"for\" (\"e\" | \"E\") \"ach\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), DEFAULT);\n        // }\n        // <END_LOCAL : <END_TAG> \"local\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_GLOBAL : <END_TAG> \"global\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_ASSIGN : <END_TAG> \"assign\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_FUNCTION : <END_TAG> \"function\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_MACRO : <END_TAG> \"macro\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_OUTPUTFORMAT : <END_TAG> \"output\" (\"f\" | \"F\") \"ormat\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), DEFAULT);\n        // }\n        // <END_AUTOESC : <END_TAG> \"auto\" (\"e\" | \"E\") \"sc\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n        // }\n        // <END_NOAUTOESC : <END_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n        //   handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        // <END_COMPRESS : <END_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_TRANSFORM : <END_TAG> \"transform\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_SWITCH : <END_TAG> \"switch\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_ESCAPE : <END_TAG> \"escape\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_NOESCAPE : <END_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        [\n          r(/(?:@endTag__id__)(@directiveEndCloseTag1)(?:@closeTag1__id__)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <UNIFIED_CALL : \"<@\" | \"[@\" > { unifiedCall(matchedToken); }\n        [\n          r(/(@open__id__)(@)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\", next: s(\"@unifiedCall__id__\") }\n          ]\n        ],\n        // <UNIFIED_CALL_END : (\"<\" | \"[\") \"/@\" ((<ID>) (\".\"<ID>)*)? <CLOSE_TAG1>> { unifiedCallEnd(matchedToken); }\n        [\n          r(/(@open__id__)(\\/@)((?:(?:@id)(?:\\.(?:@id))*)?)(?:@closeTag1__id__)/),\n          [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <TERSE_COMMENT : (\"<\" | \"[\") \"#--\" > { noparseTag = \"-->\"; handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); }\n        [\n          r(/(@open__id__)#--/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : { token: \"comment\", next: s(\"@terseComment__id__\") }\n        ],\n        // <UNKNOWN_DIRECTIVE : (\"[#\" | \"[/#\" | \"<#\" | \"</#\") ([\"a\"-\"z\", \"A\"-\"Z\", \"_\"])+>\n        [\n          r(/(?:@startOrEndTag__id__)([a-zA-Z_]+)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag.invalid\", next: s(\"@fmExpression__id__.directive\") }\n          ]\n        ]\n      ],\n      // <DEFAULT, NO_DIRECTIVE> TOKEN :\n      [s(\"interpolation_and_text_token__id__\")]: [\n        // <DOLLAR_INTERPOLATION_OPENING : \"${\"> { startInterpolation(matchedToken); }\n        // <SQUARE_BRACKET_INTERPOLATION_OPENING : \"[=\"> { startInterpolation(matchedToken); }\n        [\n          r(/(@iOpen1__id__)(@iOpen2__id__)/),\n          [\n            { token: is.id === \"bracket\" ? \"@brackets.interpolation\" : \"delimiter.interpolation\" },\n            {\n              token: is.id === \"bracket\" ? \"delimiter.interpolation\" : \"@brackets.interpolation\",\n              next: s(\"@fmExpression__id__.interpolation\")\n            }\n          ]\n        ],\n        // <STATIC_TEXT_FALSE_ALARM : \"$\" | \"#\" | \"<\" | \"[\" | \"{\"> // to handle a lone dollar sign or \"<\" or \"# or <@ with whitespace after\"\n        // <STATIC_TEXT_WS : (\"\\n\" | \"\\r\" | \"\\t\" | \" \")+>\n        // <STATIC_TEXT_NON_WS : (~[\"$\", \"<\", \"#\", \"[\", \"{\", \"\\n\", \"\\r\", \"\\t\", \" \"])+>\n        [/[\\$#<\\[\\{]|(?:@blank)+|[^\\$<#\\[\\{\\n\\r\\t ]+/, { token: \"source\" }]\n      ],\n      // <STRING_LITERAL :\n      // \t(\n      // \t\t\"\\\"\"\n      // \t\t((~[\"\\\"\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n      // \t\t\"\\\"\"\n      // \t)\n      // \t|\n      // \t(\n      // \t\t\"'\"\n      // \t\t((~[\"'\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n      // \t\t\"'\"\n      // \t)\n      // >\n      [s(\"string_single_token__id__\")]: [\n        [/[^'\\\\]/, { token: \"string\" }],\n        [/@escapedChar/, { token: \"string.escape\" }],\n        [/'/, { token: \"string\", next: \"@pop\" }]\n      ],\n      [s(\"string_double_token__id__\")]: [\n        [/[^\"\\\\]/, { token: \"string\" }],\n        [/@escapedChar/, { token: \"string.escape\" }],\n        [/\"/, { token: \"string\", next: \"@pop\" }]\n      ],\n      // <RAW_STRING : \"r\" ((\"\\\"\" (~[\"\\\"\"])* \"\\\"\") | (\"'\" (~[\"'\"])* \"'\"))>\n      [s(\"string_single_raw_token__id__\")]: [\n        [/[^']+/, { token: \"string.raw\" }],\n        [/'/, { token: \"string.raw\", next: \"@pop\" }]\n      ],\n      [s(\"string_double_raw_token__id__\")]: [\n        [/[^\"]+/, { token: \"string.raw\" }],\n        [/\"/, { token: \"string.raw\", next: \"@pop\" }]\n      ],\n      // <FM_EXPRESSION, IN_PAREN, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n      [s(\"expression_token__id__\")]: [\n        // Strings\n        [\n          /(r?)(['\"])/,\n          {\n            cases: {\n              \"r'\": [\n                { token: \"keyword\" },\n                { token: \"string.raw\", next: s(\"@rawSingleString__id__\") }\n              ],\n              'r\"': [\n                { token: \"keyword\" },\n                { token: \"string.raw\", next: s(\"@rawDoubleString__id__\") }\n              ],\n              \"'\": [{ token: \"source\" }, { token: \"string\", next: s(\"@singleString__id__\") }],\n              '\"': [{ token: \"source\" }, { token: \"string\", next: s(\"@doubleString__id__\") }]\n            }\n          }\n        ],\n        // Numbers\n        // <INTEGER : ([\"0\"-\"9\"])+>\n        // <DECIMAL : <INTEGER> \".\" <INTEGER>>\n        [\n          /(?:@integer)(?:\\.(?:@integer))?/,\n          {\n            cases: {\n              \"(?:@integer)\": { token: \"number\" },\n              \"@default\": { token: \"number.float\" }\n            }\n          }\n        ],\n        // Special hash keys that must not be treated as identifiers\n        // after a period, e.g. a.** is accessing the key \"**\" of a\n        [\n          /(\\.)(@blank*)(@specialHashKeys)/,\n          [{ token: \"delimiter\" }, { token: \"\" }, { token: \"identifier\" }]\n        ],\n        // Symbols / operators\n        [\n          /(?:@namedSymbols)/,\n          {\n            cases: {\n              \"@arrows\": { token: \"meta.arrow\" },\n              \"@delimiters\": { token: \"delimiter\" },\n              \"@default\": { token: \"operators\" }\n            }\n          }\n        ],\n        // Identifiers\n        [\n          /@id/,\n          {\n            cases: {\n              \"@keywords\": { token: \"keyword.$0\" },\n              \"@stringOperators\": { token: \"operators\" },\n              \"@default\": { token: \"identifier\" }\n            }\n          }\n        ],\n        // <OPEN_BRACKET : \"[\">\n        // <CLOSE_BRACKET : \"]\">\n        // <OPEN_PAREN : \"(\">\n        // <CLOSE_PAREN : \")\">\n        // <OPENING_CURLY_BRACKET : \"{\">\n        // <CLOSING_CURLY_BRACKET : \"}\">\n        [\n          /[\\[\\]\\(\\)\\{\\}]/,\n          {\n            cases: {\n              \"\\\\[\": {\n                cases: {\n                  \"$S2==gt\": { token: \"@brackets\", next: s(\"@inParen__id__.gt\") },\n                  \"@default\": { token: \"@brackets\", next: s(\"@inParen__id__.plain\") }\n                }\n              },\n              \"\\\\]\": {\n                cases: {\n                  ...is.id === \"bracket\" ? {\n                    \"$S2==interpolation\": { token: \"@brackets.interpolation\", next: \"@popall\" }\n                  } : {},\n                  // This cannot happen while in auto mode, since this applies only to an\n                  // fmExpression inside a directive. But once we encounter the start of a\n                  // directive, we can establish the tag syntax mode.\n                  ...ts.id === \"bracket\" ? {\n                    \"$S2==directive\": { token: \"@brackets.directive\", next: \"@popall\" }\n                  } : {},\n                  // Ignore mismatched paren\n                  [s(\"$S1==inParen__id__\")]: { token: \"@brackets\", next: \"@pop\" },\n                  \"@default\": { token: \"@brackets\" }\n                }\n              },\n              \"\\\\(\": { token: \"@brackets\", next: s(\"@inParen__id__.gt\") },\n              \"\\\\)\": {\n                cases: {\n                  [s(\"$S1==inParen__id__\")]: { token: \"@brackets\", next: \"@pop\" },\n                  \"@default\": { token: \"@brackets\" }\n                }\n              },\n              \"\\\\{\": {\n                cases: {\n                  \"$S2==gt\": { token: \"@brackets\", next: s(\"@inParen__id__.gt\") },\n                  \"@default\": { token: \"@brackets\", next: s(\"@inParen__id__.plain\") }\n                }\n              },\n              \"\\\\}\": {\n                cases: {\n                  ...is.id === \"bracket\" ? {} : {\n                    \"$S2==interpolation\": { token: \"@brackets.interpolation\", next: \"@popall\" }\n                  },\n                  // Ignore mismatched paren\n                  [s(\"$S1==inParen__id__\")]: { token: \"@brackets\", next: \"@pop\" },\n                  \"@default\": { token: \"@brackets\" }\n                }\n              }\n            }\n          }\n        ],\n        // <OPEN_MISPLACED_INTERPOLATION : \"${\" | \"#{\" | \"[=\">\n        [/\\$\\{/, { token: \"delimiter.invalid\" }]\n      ],\n      // <FM_EXPRESSION, IN_PAREN, NAMED_PARAMETER_EXPRESSION> SKIP :\n      [s(\"blank_and_expression_comment_token__id__\")]: [\n        // < ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )+ >\n        [/(?:@blank)+/, { token: \"\" }],\n        // < (\"<\" | \"[\") (\"#\" | \"!\") \"--\"> : EXPRESSION_COMMENT\n        [/[<\\[][#!]--/, { token: \"comment\", next: s(\"@expressionComment__id__\") }]\n      ],\n      // <FM_EXPRESSION, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n      [s(\"directive_end_token__id__\")]: [\n        // <DIRECTIVE_END : \">\">\n        // {\n        //     if (inFTLHeader) {\n        //         eatNewline();\n        //         inFTLHeader = false;\n        //     }\n        //     if (squBracTagSyntax || postInterpolationLexState != -1 /* We are in an interpolation */) {\n        //         matchedToken.kind = NATURAL_GT;\n        //     } else {\n        //         SwitchTo(DEFAULT);\n        //     }\n        // }\n        // This cannot happen while in auto mode, since this applies only to an\n        // fmExpression inside a directive. But once we encounter the start of a\n        // directive, we can establish the tag syntax mode.\n        [\n          />/,\n          ts.id === \"bracket\" ? { token: \"operators\" } : { token: \"@brackets.directive\", next: \"@popall\" }\n        ],\n        // <EMPTY_DIRECTIVE_END : \"/>\" | \"/]\">\n        // It is a syntax error to end a tag with the wrong close token\n        // Let's indicate that to the user by not closing the tag\n        [\n          r(/(\\/)(@close__id__)/),\n          [{ token: \"delimiter.directive\" }, { token: \"@brackets.directive\", next: \"@popall\" }]\n        ]\n      ],\n      // <IN_PAREN> TOKEN :\n      [s(\"greater_operators_token__id__\")]: [\n        // <NATURAL_GT : \">\">\n        [/>/, { token: \"operators\" }],\n        // <NATURAL_GTE : \">=\">\n        [/>=/, { token: \"operators\" }]\n      ],\n      // <NO_SPACE_EXPRESSION> TOKEN :\n      [s(\"no_space_expression_end_token__id__\")]: [\n        // <TERMINATING_WHITESPACE :  ([\"\\n\", \"\\r\", \"\\t\", \" \"])+> : FM_EXPRESSION\n        [/(?:@blank)+/, { token: \"\", switchTo: s(\"@fmExpression__id__.directive\") }]\n      ],\n      [s(\"unified_call_token__id__\")]: [\n        // Special case for a call where the expression is just an ID\n        // <UNIFIED_CALL> <ID> <BLANK>+\n        [\n          /(@id)((?:@blank)+)/,\n          [{ token: \"tag\" }, { token: \"\", next: s(\"@fmExpression__id__.directive\") }]\n        ],\n        [\n          r(/(@id)(\\/?)(@close__id__)/),\n          [\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\", next: \"@popall\" }\n          ]\n        ],\n        [/./, { token: \"@rematch\", next: s(\"@noSpaceExpression__id__\") }]\n      ],\n      // <NO_PARSE> TOKEN :\n      [s(\"no_parse_token__id__\")]: [\n        // <MAYBE_END :\n        // \t (\"<\" | \"[\")\n        // \t \"/\"\n        // \t (\"#\")?\n        // \t ([\"a\"-\"z\", \"A\"-\"Z\"])+\n        // \t ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )*\n        // \t (\">\" | \"]\")\n        // >\n        [\n          r(/(@open__id__)(\\/#?)([a-zA-Z]+)((?:@blank)*)(@close__id__)/),\n          {\n            cases: {\n              \"$S2==$3\": [\n                { token: \"@brackets.directive\" },\n                { token: \"delimiter.directive\" },\n                { token: \"tag\" },\n                { token: \"\" },\n                { token: \"@brackets.directive\", next: \"@popall\" }\n              ],\n              \"$S2==comment\": [\n                { token: \"comment\" },\n                { token: \"comment\" },\n                { token: \"comment\" },\n                { token: \"comment\" },\n                { token: \"comment\" }\n              ],\n              \"@default\": [\n                { token: \"source\" },\n                { token: \"source\" },\n                { token: \"source\" },\n                { token: \"source\" },\n                { token: \"source\" }\n              ]\n            }\n          }\n        ],\n        // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n        // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n        [\n          /[^<\\[\\-]+|[<\\[\\-]/,\n          {\n            cases: {\n              \"$S2==comment\": { token: \"comment\" },\n              \"@default\": { token: \"source\" }\n            }\n          }\n        ]\n      ],\n      // <EXPRESSION_COMMENT> SKIP:\n      [s(\"expression_comment_token__id__\")]: [\n        // < \"-->\" | \"--]\">\n        [\n          /--[>\\]]/,\n          {\n            token: \"comment\",\n            next: \"@pop\"\n          }\n        ],\n        // < (~[\"-\", \">\", \"]\"])+ >\n        // < \">\">\n        // < \"]\">\n        // < \"-\">\n        [/[^\\->\\]]+|[>\\]\\-]/, { token: \"comment\" }]\n      ],\n      [s(\"terse_comment_token__id__\")]: [\n        //  <TERSE_COMMENT_END : \"-->\" | \"--]\">\n        [r(/--(?:@close__id__)/), { token: \"comment\", next: \"@popall\" }],\n        // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n        // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n        [/[^<\\[\\-]+|[<\\[\\-]/, { token: \"comment\" }]\n      ]\n    }\n  };\n}\nfunction createMonarchLanguageAuto(is) {\n  const angle = createMonarchLanguage(TagSyntaxAngle, is);\n  const bracket = createMonarchLanguage(TagSyntaxBracket, is);\n  const auto = createMonarchLanguage(TagSyntaxAuto, is);\n  return {\n    // Angle and bracket syntax mode\n    // We switch to one of these once we have determined the mode\n    ...angle,\n    ...bracket,\n    ...auto,\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: `default_auto_${is.id}`,\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: `.freemarker2`,\n    brackets: [\n      { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n      { open: \"[\", close: \"]\", token: \"delimiter.square\" },\n      { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n      { open: \"<\", close: \">\", token: \"delimiter.angle\" }\n    ],\n    tokenizer: {\n      ...angle.tokenizer,\n      ...bracket.tokenizer,\n      ...auto.tokenizer\n    }\n  };\n}\nvar TagAngleInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxDollar)\n};\nvar TagBracketInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxDollar)\n};\nvar TagAngleInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxBracket)\n};\nvar TagBracketInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxBracket)\n};\nvar TagAutoInterpolationDollar = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxDollar)\n};\nvar TagAutoInterpolationBracket = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxBracket)\n};\nexport {\n  TagAngleInterpolationBracket,\n  TagAngleInterpolationDollar,\n  TagAutoInterpolationBracket,\n  TagAutoInterpolationDollar,\n  TagBracketInterpolationBracket,\n  TagBracketInterpolationDollar\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$181d7191d7e7a5bf$export$9945f5d7c02ad2fc","$181d7191d7e7a5bf$export$6f4f6c4e91d5ee59","$181d7191d7e7a5bf$export$1cb623f6377415e8","$181d7191d7e7a5bf$export$d0605717f8750fe2","$181d7191d7e7a5bf$export$b685ef20e1dddf83","$181d7191d7e7a5bf$export$d2238c7b2ec81a45","$cDseA","$181d7191d7e7a5bf$var$__defProp","$181d7191d7e7a5bf$var$__getOwnPropDesc","getOwnPropertyDescriptor","$181d7191d7e7a5bf$var$__getOwnPropNames","getOwnPropertyNames","$181d7191d7e7a5bf$var$__hasOwnProp","prototype","hasOwnProperty","$181d7191d7e7a5bf$var$monaco_editor_core_exports","$181d7191d7e7a5bf$var$__copyProps","to","from","except","desc","key","call","$181d7191d7e7a5bf$var$EMPTY_ELEMENTS","$181d7191d7e7a5bf$var$BLOCK_ELEMENTS","$181d7191d7e7a5bf$var$TagSyntaxAngle","close","id","open","$181d7191d7e7a5bf$var$TagSyntaxBracket","$181d7191d7e7a5bf$var$TagSyntaxAuto","$181d7191d7e7a5bf$var$InterpolationSyntaxDollar","open1","open2","$181d7191d7e7a5bf$var$InterpolationSyntaxBracket","$181d7191d7e7a5bf$var$createLangConfiguration","ts","brackets","comments","blockComment","autoCloseBefore","autoClosingPairs","notIn","surroundingPairs","folding","markers","start","RegExp","join","end","onEnterRules","beforeText","afterText","action","indentAction","languages","IndentAction","IndentOutdent","Indent","$181d7191d7e7a5bf$var$createLangConfigurationAuto","$181d7191d7e7a5bf$var$createMonarchLanguage","is","name","replace","r","regexp","source","flags","unicode","includeLF","ignoreCase","defaultToken","tokenPostfix","token","blank","keywords","directiveStartCloseTag1","directiveStartCloseTag2","directiveStartBlank","directiveEndCloseTag1","escapedChar","asciiDigit","integer","nonEscapedIdStartChar","escapedIdChar","idStartChar","specialHashKeys","namedSymbols","arrows","delimiters","stringOperators","noParseTags","tokenizer","include","cases","switchTo","next","$181d7191d7e7a5bf$var$createMonarchLanguageAuto","angle","bracket","auto","conf","language"],"version":3,"file":"freemarker2.2650a4f7.js.map"}